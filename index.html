<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Quattrocento+Sans:ital,wght@0,400;0,700;1,400;1,700&family=Quattrocento:wght@400;700&family=Rubik+Mono+One&display=swap" rel="stylesheet">
  <title>Browser ROM Patcher</title>
  <style>
    .rubik-mono-one-regular {
      font-family: "Rubik Mono One", serif;
      font-weight: 400;
      font-style: normal;
    }
    .quattrocento-sans-regular {
      font-family: "Quattrocento Sans", serif;
      font-weight: 400;
      font-style: normal;
    }
    body {
      font-family: "Quattrocento Sans", Arial, sans-serif;
      background: palegoldenrod;
    }
    h1 {
        font-family: "Rubik Mono One", serif;
    }
    h2 {
        font-family: "Rubik Mono One", serif;
    }
    .file-upload {
      margin-bottom: 10px;
      background-color: palegoldenrod;
    }
    #additional-uploads {
      margin-top: 10px;
    }
    #manifest {
      white-space: pre-wrap;
      margin-top: 20px;
      margin-left: 20px;
      background-color: antiquewhite;
    }
    #patch {
      background-color: papayawhip;
      font-family: "Rubik Mono One", serif;
    }
/* adapted from https://stackoverflow.com/questions/23441060/how-to-animate-gradients-using-css */
    #gradient
{
    height:100vh;
    width:100vw;
    background: linear-gradient(130deg, palegoldenrod, #ffffff, papayawhip);
    background-size: 200% 200%;

    -webkit-animation: Animation 23s ease infinite;
    -moz-animation: Animation 23s ease infinite;
    animation: Animation 23s ease infinite;
}

@-webkit-keyframes Animation {
    0%{background-position:10% 0%}
    50%{background-position:91% 100%}
    100%{background-position:10% 0%}
}
@-moz-keyframes Animation {
    0%{background-position:10% 0%}
    50%{background-position:91% 100%}
    100%{background-position:10% 0%}
}
@keyframes Animation { 
    0%{background-position:10% 0%}
    50%{background-position:91% 100%}
    100%{background-position:10% 0%}
}
  </style>
  <!-- for unzipping GitHub archives -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>


</head>
<body id="gradient">
  <h1>FF5r Clean Patcher</h1>
  <h3>
    by xJ4cks & ChatGPT4
  </h3>
  <p>Upload your FFVJ ROM and multiple IPS patches to create a patched ROM.</p>

  <!-- ROM Upload -->
  <div class="file-upload">
    <label for="rom">ROM File (.sfc):</label>
    <input type="file" id="rom" accept=".sfc">
  </div>


   <!-- test dropdown of patches -->
   <h2>Choose the Features</h2>
   <select id="patch-dropdown">
       <option value="" disabled selected>Select a patch</option>
   </select>    

    <button id="applyPatch">Apply Patch</button>


  <script>

    function applyIpsPatch(romData, ipsData) {
    const IPS_HEADER = "PATCH";
    const IPS_FOOTER = "EOF";

    let offset = 0;

    // Verify header
    const header = new TextDecoder().decode(ipsData.slice(0, 5));
    if (header !== IPS_HEADER) throw new Error("Invalid IPS file: Incorrect header.");
    offset += 5;

    while (offset < ipsData.length) {
        // Check for footer
        if (offset + 3 <= ipsData.length) {
        const footer = new TextDecoder().decode(ipsData.slice(offset, offset + 3));
            if (footer === IPS_FOOTER) {
                // Valid footer, end processing
                return romData;
            }
        }

        // Read patch address
        if (offset + 3 > ipsData.length) throw new Error("Invalid IPS file: Unexpected end of data while reading address.");
        const address = (ipsData[offset] << 16) | (ipsData[offset + 1] << 8) | ipsData[offset + 2];
        offset += 3;

        // Read patch size
        if (offset + 2 > ipsData.length) throw new Error("Invalid IPS file: Unexpected end of data while reading size.");
        const size = (ipsData[offset] << 8) | ipsData[offset + 1];
        offset += 2;

        if (size === 0) {
        // RLE (Run Length Encoding)
        if (offset + 3 > ipsData.length) throw new Error("Invalid IPS file: Unexpected end of data in RLE encoding.");
        const rleSize = (ipsData[offset] << 8) | ipsData[offset + 1];
        const value = ipsData[offset + 2];
        offset += 3;

        // Apply RLE to ROM data
        for (let i = 0; i < rleSize; i++) {
            if (address + i >= romData.length) throw new Error("Invalid IPS file: Address out of bounds during RLE.");
            romData[address + i] = value;
        }
        } else {
        // Normal patch
        if (offset + size > ipsData.length) throw new Error("Invalid IPS file: Unexpected end of data in normal patch.");
        const patchData = ipsData.slice(offset, offset + size);
        offset += size;

        // Apply patch to ROM data
        for (let i = 0; i < size; i++) {
            if (address + i >= romData.length) throw new Error("Invalid IPS file: Address out of bounds during normal patch.");
            romData[address + i] = patchData[i];
        }
        }
    }

    throw new Error("Invalid IPS file: Missing footer.");
      // Mockup: Replace this w a directory reading method
    function fetchPatches() {
        // Simulate patch filenames
        return [
            "FF5r Clean.ips",
            "FF5r Deep Clean.ips",
            "FF5r Super Deep Clean.ips",
            "FF5r Super Special Deep Clean.ips",
            "FF5r Super Special Double Deep Clean.ips",
        ];
    }
  
    document.addEventListener("DOMContentLoaded", () => {
        const patchDropdown = document.getElementById("patchDropdown");
        const patches = fetchPatches(); // Fetches patch list

        // Populatees dropdown menu with patch options
        patches.forEach(patch => {
            const option = document.createElement("option");
            option.value = patch;
            option.textContent = patch;
            patchDropdown.appendChild(option);
        });

        // Adds event listener for the "Apply Patch" button
        document.getElementById("applyPatch").addEventListener("click", () => {
            const selectedPatch = patchDropdown.value;
            if (selectedPatch) {
                alert(`Applying patch: ${selectedPatch}`);
                // Logic to apply the selected patch goes here; see above
            } else {
                alert("Please select a patch to apply!");
            }
        });
    });

    async function loadLocalZip() {
    const zipFilePath = './ff5rc.zip';
    try {
        const response = await fetch(zipFilePath);
        if (!response.ok) {
            throw new Error(`Failed to fetch ZIP file: ${response.statusText}`);
        }

        const zipBlob = await response.blob();
        const zip = await JSZip.loadAsync(zipBlob);

        console.log('ZIP file loaded successfully:', zip);

        // Extract files from the specific directory
        const patchFiles = Object.keys(zip.files).filter(relativePath =>
            relativePath.startsWith('/') &&
            !zip.files[relativePath].dir
        );

        console.log('Filtered patch files:', patchFiles);

        populateDropdown(patchFiles);
    } catch (error) {
        console.error('Error loading or processing ZIP file:', error);
    }
  }
  function populateDropdown(patchFiles) {
      const patchDropdown = document.getElementById('patch-dropdown');
      if (!patchDropdown) {
          console.error('Dropdown element not found');
          return;
      }

      // Clear existing options
      patchDropdown.innerHTML = '';

      // Populate dropdown
      patchFiles.forEach(relativePath => {
          const option = document.createElement("option");
          option.value = relativePath;
          option.textContent = relativePath.split('/').pop(); // Show only the file name
          patchDropdown.appendChild(option);
          console.log('Added to dropdown:', relativePath);
      });

      console.log('Dropdown options populated:', patchDropdown.options.length);
  }
}
</script>
</body>
</html>
